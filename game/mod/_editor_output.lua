-- Generated by LuaSTG
-- Mod name: Touhou Roguelike

ColorList = { { 250, 99, 71 },
              { 221, 160, 221 },
              { 135, 206, 235 },
              { 127, 255, 212 },
              { 189, 252, 201 },
              { 255, 227, 132 },
              { 243, 152, 57 },
              { 192, 192, 192 } }

WhiteScreen = Class(object, {
    init = function(self, Layer, time, blend)
        self.lifetime = time or 30
        self.layer = Layer or LAYER.TOP
        self.group = GROUP.GHOST
        self.blend = blend or ""
    end,
    frame = function(self)
        if self.timer >= self.lifetime then
            object.RawDel(self)
        end
    end,
    render = function(self)
        SetImageState("white", self.blend, 255 * (1 - self.timer / self.lifetime), 255, 255, 255)
        RenderRect("white", lstg.world.l, lstg.world.r, lstg.world.b, lstg.world.t)
    end
})
local PulseScreen = Class(object, {
    init = function(self, layer, col, blend, fade_in, stay, fade_out)
        self.layer = layer or LAYER.TOP
        self.group = GROUP.GHOST
        self.blend = blend or ""
        self._r, self._g, self._b = unpack(col or { 255, 255, 255 })
        fade_in = fade_in or 0
        stay = stay or 0
        fade_out = fade_out or 0
        self.lifetime = fade_in + stay + fade_out
        if fade_in > 0 then
            self._a = 0
        else
            self._a = 255
        end
        self.fade_in_mode = 0
        self.fade_out_mode = 0
        task.New(self, function()
            fade_in = int(fade_in)
            fade_out = int(fade_out)
            for i = 1, fade_in do
                self._a = task.SetMode[self.fade_in_mode](i / fade_in) * 255
                task.Wait()
            end
            task.Wait(stay)
            for i = 1, fade_out do
                self._a = 255 - task.SetMode[self.fade_out_mode](i / fade_out) * 255
                task.Wait()
            end
        end)

    end,
    frame = function(self)
        task.Do(self)
        if self.timer >= self.lifetime then
            object.RawDel(self)
        end
    end,
    render = function(self)
        SetImageState("white", self.blend, self._a, self._r, self._g, self._b)
        RenderRect("white", lstg.world.l, lstg.world.r, lstg.world.b, lstg.world.t)
    end
})
function NewPulseScreen(layer, col, blend, fade_in, stay, fade_out)
    return New(PulseScreen, layer, col, blend, fade_in, stay, fade_out)
end
do
    local wave = Class(object, {
        init = function(unit, x, y, w, sr, time, r, g, b, ir)
            unit.x, unit.y = x, y
            unit.layer = 1
            unit.group = GROUP.GHOST
            unit.w = w
            unit.sr = sr
            unit.time = time
            unit.ir = ir or 0
            unit.nr = unit.ir
            unit.smear = {}
            unit.alpha = 255
            unit.colli = false
            unit._r, unit._g, unit._b = r or 255, g or 255, b or 255
        end,
        frame = function(unit)

            unit.lr = unit.nr
            unit.alpha = max(0, 255 * (1 - unit.timer / unit.time))
            unit.nr = unit.ir + task.SetMode[2](unit.timer / unit.time) * (unit.sr - unit.ir)
            if unit.timer > unit.time then
                if #unit.smear == 0 then
                    Del(unit)
                end
            else
                table.insert(unit.smear, { alpha = unit.alpha / 2, r = unit.nr, w = (unit.nr - unit.lr) })
            end
            local s
            for i = #unit.smear, 1, -1 do
                s = unit.smear[i]
                s.alpha = max(s.alpha - 15, 0)
                if s.alpha == 0 then
                    table.remove(unit.smear, i)
                end
            end
        end,
        render = function(unit)
            SetImageState("white", "mul+add", unit.alpha, unit._r, unit._g, unit._b)
            misc.SectorRender(unit.x, unit.y, unit.nr - unit.w / 2, unit.nr + unit.w / 2,
                    0, 360, int(Forbid(unit.nr / 4, 20, 80)))
            for _, s in ipairs(unit.smear) do
                SetImageState("white", "mul+add", s.alpha, unit._r, unit._g, unit._b)
                misc.SectorRender(unit.x, unit.y, s.r - s.w, s.r, 0, 360,
                        int(Forbid(s.r / 4, 20, 80)))
            end
        end
    })
    local wave2 = Class(object, {
        init = function(unit, x, y, w, ir, sr, time, r, g, b, dealpha, interval)
            unit.x, unit.y = x, y
            unit.layer = 1
            unit.group = GROUP.GHOST
            unit.w = w
            unit.sr = sr
            unit.time = time
            unit.ir = ir or 0
            unit.nr = unit.ir
            unit.smear = {}
            unit.alpha = 255
            unit.colli = false
            unit._r, unit._g, unit._b = r or 255, g or 255, b or 255
            unit.dealpha = dealpha or 2
            unit.interval = interval or 1
        end,
        frame = function(unit)

            unit.lr = unit.nr
            unit.alpha = max(0, 255 * (1 - unit.timer / unit.time))
            unit.nr = unit.ir + task.SetMode[2](unit.timer / unit.time) * (unit.sr - unit.ir)
            if unit.timer > unit.time then
                if #unit.smear == 0 then
                    Del(unit)
                end
            else
                if unit.timer % unit.interval == 0 then
                    table.insert(unit.smear, { alpha = unit.alpha / 2, r = unit.nr, w = unit.w })
                end
            end
            local s
            for i = #unit.smear, 1, -1 do
                s = unit.smear[i]
                s.alpha = max(s.alpha - unit.dealpha, 0)
                if s.alpha == 0 then
                    table.remove(unit.smear, i)
                end
            end
        end,
        render = function(unit)
            SetImageState("white", "mul+add", unit.alpha, unit._r, unit._g, unit._b)
            misc.SectorRender(unit.x, unit.y, unit.nr - unit.w / 2, unit.nr + unit.w / 2,
                    0, 360, int(Forbid(unit.nr / 4, 20, 80)))
            for _, s in ipairs(unit.smear) do
                SetImageState("white", "mul+add", s.alpha, unit._r, unit._g, unit._b)
                misc.SectorRender(unit.x, unit.y, s.r - s.w, s.r, 0, 360,
                        int(Forbid(s.r / 4, 20, 80)))
            end
        end
    })
    local bon = Class(object, {
        init = function(self, x, y, time, radius, r, g, b)
            self.x, self.y = x, y
            self.layer = LAYER.ENEMY + 1
            self.group = GROUP.GHOST
            self.colli = false
            self.lifetime = time
            self.r = radius
            self.alpha = 1
            self._r, self._g, self._b = r, g, b
            self.particle = {}
            for _ = 1, 15 + setting.rdQual * 3 do
                local a = ran:Float(0, 360)
                local v = ran:Float(3, 6)
                table.insert(self.particle, {
                    x = self.x, y = self.y,
                    vx = cos(a) * v, vy = sin(a) * v,
                    alpha = ran:Float(150, 250), timer = 0,
                })
            end
            task.New(self, function()
                task.SmoothSetValueTo("alpha", 0, time, 0)
            end)
        end,
        frame = function(self)
            task.Do(self)
            local p
            local maxtime = max(10, self.lifetime - 20)
            for i = #self.particle, 1, -1 do
                p = self.particle[i]
                p.x = p.x + p.vx
                p.y = p.y + p.vy
                p.vx = p.vx - p.vx * 0.04
                p.vy = p.vy - p.vy * 0.04
                if p.timer > maxtime then
                    p.alpha = max(p.alpha - 5, 0)
                    if p.alpha == 0 then
                        table.remove(self.particle, i)
                    end
                end
                p.timer = p.timer + 1
            end
            if self.timer >= self.lifetime and #self.particle == 0 then
                object.Del(self)
            end
        end,
        render = function(self)
            for _, p in ipairs(self.particle) do
                SetImageState("bright", "mul+add", p.alpha, self._r, self._g, self._b)
                Render("bright", p.x, p.y, 0, 8 / 150)
            end
            if self.alpha > 0 then
                SetImageState("bright", "mul+add", self.alpha * 255, self._r, self._g, self._b)
                Render("bright", self.x, self.y, 0, self.r / 75)
            end
        end
    })
    function NewBon(x, y, time, radius, r, g, b)
        return New(bon, x, y, time, radius, r, g, b)
    end
    function NewWave(x, y, width, maxr, time, r, g, b, ir)
        return New(wave, x, y, width, maxr, time, r, g, b, ir)
    end
    function NewWave2(x, y, w, ir, sr, time, r, g, b, dealpha, interval)
        return New(wave2, x, y, w, ir, sr, time, r, g, b, dealpha, interval)
    end
end

function SmearScreen(NAME, lifetime, time, bottom, top, blend, inclt, maxlt, del_immediately, R, G, B)
    inclt = inclt or 0
    maxlt = maxlt or 9999
    bottom = bottom or (LAYER.BG - 10)
    top = top or (LAYER.TOP - 1)
    blend = blend or "mul+add"
    NAME = NAME or "SmearScreen_EFF"
    R = R or 255
    G = G or 255
    B = B or 255
    local obj = New(Class(object, {
        frame = task.Do
    }, true))
    obj.D = 1
    task.New(obj, function()

        local _uv1, _uv2, _uv3, _uv4 = { [3] = 0.5 }, { [3] = 0.5 }, { [3] = 0.5 }, { [3] = 0.5 }
        local w = lstg.world
        _uv1[1], _uv1[2] = w.l, w.t
        _uv2[1], _uv2[2] = w.r, w.t
        _uv3[1], _uv3[2] = w.r, w.b
        _uv4[1], _uv4[2] = w.l, w.b
        _uv1[4], _uv1[5] = WorldToScreen(w.l, w.t)
        _uv2[4], _uv2[5] = WorldToScreen(w.r, w.t)
        _uv3[4], _uv3[5] = WorldToScreen(w.r, w.b)
        _uv4[4], _uv4[5] = WorldToScreen(w.l, w.b)
        local objs = {}
        local maxk = 1
        local k = 1
        for i = 1, time do
            if obj.flag then
                break
            end
            local name = NAME .. k
            CreateRenderTarget(name)
            table.insert(objs, New(Class(object, {
                init = function(unit)
                    unit.layer = bottom
                    unit.colli = false
                end,
                frame = function(unit)
                    if unit.timer >= lifetime then
                        Del(unit)
                    end
                end,
                render = function(unit)
                    if unit.timer == 1 and lifetime >= 1 then
                        PushRenderTarget(name)
                        RenderClear(Color(0, 0, 0, 0))
                    end
                end
            }, true)))
            table.insert(objs, New(Class(object, {
                init = function(unit)
                    unit.layer = top - i * 0.00001 * obj.D
                    unit.colli = false
                end,
                frame = function(unit)
                    if unit.timer >= lifetime then
                        Del(unit)
                    end
                end,
                render = function(unit)
                    if lifetime >= 1 then
                        if unit.timer == 1 then
                            PopRenderTarget(name)
                        end
                        local _color = Color(max(1 - (unit.timer - 1) / lifetime, 0) * 255, R, G, B)
                        _uv1[6] = _color
                        _uv2[6] = _color
                        _uv3[6] = _color
                        _uv4[6] = _color
                        RenderTexture(name, blend, _uv1, _uv2, _uv3, _uv4)
                    end
                end
            }, true)))

            lifetime = min(lifetime + inclt, maxlt)
            k = k + 1
            if i % (lifetime + 1) == 0 then
                k = 1
            end
            maxk = max(maxk, k)
            task.Wait()
        end
        if del_immediately then
            sp:UnitListUpdate(objs)
            for _, o in ipairs(objs) do
                object.RawDel(o)
            end
        else
            task.Wait(lifetime)
        end
        for i = 1, maxk do
            RemoveResource("stage", 1, NAME .. i)
        end
        Del(obj)
    end)
    return obj
end

---@param rotpower number@角度的power
function TelescopeScreen(self, lifetime, power, rotpower, mode)
    rotpower = rotpower or 0
    mode = mode or 2
    task.New(self, function()
        local scr = screen
        local uv1, uv2, uv3, uv4 = { [3] = 0.5 }, { [3] = 0.5 }, { [3] = 0.5 }, { [3] = 0.5 }
        local w, h = scr.width, scr.height
        uv1[4], uv1[5] = UIToScreen(0, h)
        uv2[4], uv2[5] = UIToScreen(w, h)
        uv3[4], uv3[5] = UIToScreen(w, 0)
        uv4[4], uv4[5] = UIToScreen(0, 0)
        local color = Color(255, 255, 255, 255)
        uv1[6], uv2[6], uv3[6], uv4[6] = color, color, color, color
        task.New(self, function()
            for i = 1, lifetime do
                local cx, cy = w / 2, h / 2
                ext.OtherScreenEff:Open(function(eff)
                    local scale = 1 + power - power * task.SetMode[mode](i / lifetime)
                    local rot = rotpower - rotpower * task.SetMode[mode](i / lifetime)
                    local cosr = cos(rot)
                    local sinr = sin(rot)
                    local _w, _h = w / 2 * scale, h / 2 * scale
                    uv1[1], uv1[2] = cx - _w * cosr - _h * sinr, cy + _h * cosr - _w * sinr
                    uv2[1], uv2[2] = cx + _w * cosr - _h * sinr, cy + _h * cosr + _w * sinr
                    uv3[1], uv3[2] = cx + _w * cosr + _h * sinr, cy - _h * cosr + _w * sinr
                    uv4[1], uv4[2] = cx - _w * cosr + _h * sinr, cy - _h * cosr - _w * sinr
                    RenderTexture(eff.name, "mul+add", uv1, uv2, uv3, uv4)
                end)
                task.Wait()
            end
        end)
    end)
end
function TelescopeSmearScreen(self, lifetime, power)
    task.New(self, function()
        local uv1, uv2, uv3, uv4 = { [3] = 0.5 }, { [3] = 0.5 }, { [3] = 0.5 }, { [3] = 0.5 }
        local w, h = screen.width, screen.height
        uv1[4], uv1[5] = UIToScreen(0, h)
        uv2[4], uv2[5] = UIToScreen(w, h)
        uv3[4], uv3[5] = UIToScreen(w, 0)
        uv4[4], uv4[5] = UIToScreen(0, 0)
        local cx = w / 2
        local cy = h / 2
        local w1, w2 = cx, w - cx
        local h1, h2 = cy, h - cy
        for i = 1, lifetime do
            local scale = 1 + task.SetMode[2](i / lifetime) * power
            local color = Color(100 - 100 * task.SetMode[1](i / lifetime), 255, 255, 255)
            ext.OtherScreenEff:Open(function(scr)
                uv1[6], uv2[6], uv3[6], uv4[6] = color, color, color, color
                uv1[1], uv1[2] = cx - w1 * scale, cy + h2 * scale
                uv2[1], uv2[2] = cx + w2 * scale, cy + h2 * scale
                uv3[1], uv3[2] = cx + w2 * scale, cy - h1 * scale
                uv4[1], uv4[2] = cx - w1 * scale, cy - h1 * scale
                RenderTexture(scr.name, "", uv1, uv2, uv3, uv4)
            end,
                    true)
            task.Wait()
        end
    end)
end

do
    local task, object = task, object
    local type, table = type, table

    local _bullet = Class(bullet, {
        frame = function(self)
            if self.frame_new then
                self:frame_new()
            else
                bullet.frame(self)
            end
        end,
        render = function(self)
            if self.render_new then
                self:render_new()
            else
                bullet.render(self)
            end
        end
    })
    ---@param blend number@快速设置高光
    function _bullet:init(imgclass, index, stay, indes, blend, x, y)
        bullet.init(self, imgclass, index, stay, indes)
        self._blend = blend and "mul+add" or self._blend
        self.x, self.y = x, y
        self.autorot = bullet.GetNavi(self)
    end
    CreateRenderTarget("SimpleText")
    LoadFX("fx:WORLDROTATE", "shader\\world_rotate.hlsl")
    SimpleText = Class(object, {
        init = function(self, x, y, layer, text, alpha, color, lifetime, f, viewmode, ...)
            self.x, self.y = x, y
            self.layer = layer or LAYER.TOP
            self.group = GROUP.GHOST
            self.colli = false
            self.bound = false
            self.text = text or ""
            self.alpha = alpha or 0
            self.color = color or { 255, 255, 255 }
            self.other = { ... }
            self.lifetime = lifetime
            self.viewmode = viewmode or "world"
            self.size = 1
            self.type = "small_text"
            self.rot = 0
            self.blend = ""
            self.outline = true--默认描边
            self.offscale = 1
            task.New(self, f or function()
            end)
        end,
        frame = function(self)
            task.Do(self)
            if self.lifetime and self.timer >= self.lifetime then
                object.RawDel(self)
            end
        end,
        render = function(self)
            SetViewMode(self.viewmode)
            if self.outline then
                for i = 1, 4 do
                    RenderTTF3(self.type, self.text, self.x + cos(i * 90 + 45), self.y + sin(i * 90 + 45), self.rot,
                            self.size * self.hscale * 0.5, self.size * self.vscale * 0.5,
                            "", Color(self.alpha, 0, 0, 0), unpack(self.other))
                end
            end
            RenderTTF3(self.type, self.text, self.x, self.y, self.rot,
                    self.size * self.hscale * 0.5, self.size * self.vscale * 0.5,
                    self.blend, Color(self.alpha, unpack(self.color)), unpack(self.other))
            SetViewMode("world")
        end
    })
    function NewLyrics(x, y, text, alpha, color, viewmode, event, mode, ttfname)
        local u = New(SimpleText, x, y, 160, text, alpha, color, nil, event, viewmode, mode or "center")
        u.type = ttfname or u.type
        return u
    end
    function SimpleText.MusicSign(text, color)
        New(SimpleText, 313, -260, 0, text, 0, color, nil, function()
            local self = task.GetSelf()
            self.size = 0.85
            task.New(self, function()
                while true do
                    local k = Forbid(Dist(self, player) / 200, 0.4, 0.8)
                    self.alpha = 255 * k
                    task.Wait()
                end
            end)
            task.MoveTo(313, -222, 60, 2)
            task.Wait(180)
            task.MoveTo(450, -222, 60, 1)
            object.RawDel(self)
        end, nil, "right")
    end

    global_obj = {}
    local global_obj = global_obj
    --承载着简单事件的简单弹
    global_obj["bullet_decel"] = Class(_bullet, { init = function(self, _x, _y, style, col, fv, v, a, blend, stay)
        _bullet.init(self, style, col, (stay or stay == nil) and true, true, blend, _x, _y)
        self.wait = 0
        self.time = 25
        object.SetV(self, fv, a, self.autorot)
        task.New(self, function()
            task.Wait(self.wait)
            self.autorot = bullet.GetNavi(self)
            object.ChangingV(self, fv, v, a, self.time, self.autorot)
        end)
    end })
    global_obj["bullet_accel"] = Class(_bullet, { init = function(self, _x, _y, style, col, fv, v, a, blend, stay, wait, time)
        _bullet.init(self, style, col, (stay or stay == nil) and true, true, blend, _x, _y)
        self.wait = wait or 60
        self.time = time or 120
        object.SetV(self, fv, a, self.autorot)
        task.New(self, function()
            task.Wait(self.wait)
            self.autorot = bullet.GetNavi(self)
            object.ChangingV(self, fv, v, a, self.time, self.autorot)
        end)
    end })
    global_obj["bullet_dec_acc"] = Class(_bullet, { init = function(self, _x, _y, style, col, fv, v, a, blend, stay)
        _bullet.init(self, style, col, (stay or stay == nil) and true, true, blend, _x, _y)
        self.time1, self.time2, self.time3 = 25, 60, 120
        object.SetV(self, fv, a, self.autorot)
        task.New(self, function()
            object.ChangingV(self, fv, 0.5, a, self.time1, self.autorot)
            task.Wait(self.time2)
            object.ChangingV(self, 0.5, v, a, self.time3, self.autorot)
        end)
    end })
    global_obj["bullet_dec_setangle"] = Class(_bullet, { init = function(self, _x, _y, sty, col, ...)
        local c = { ... }
        local t = true
        if type(c[1]) == "boolean" then
            t = c[1]
            table.remove(c, 1)
        end
        _bullet.init(self, sty, col, t, true, false, _x, _y)
        object.SetV(self, c[1].v, c[1].a, self.autorot)
        task.New(self, function()
            for i, con in ipairs(c) do
                if con.v and con.a then
                    object.SetV(self, con.v, con.a, self.autorot)
                end
                if con.func then
                    con.func(self)
                end
                PlaySound("kira00", 0.1, self.x / 256, true)
                if i == #c then
                    break
                end
                object.ChangingV(self, con.v, 0, con.a, int(con.time or 0), self.autorot, 5)
                task.Wait(con.wait or 0)
            end
        end)
    end })
    global_obj["bullet_changeangle"] = Class(_bullet, { init = function(self, _x, _y, sty, col, v, a, ...)
        local c = { ... }
        local t = true
        if type(c[1]) == "boolean" then
            t = c[1]
            table.remove(c, 1)
        end
        _bullet.init(self, sty, col, t, true, false, _x, _y)
        self.angle = a
        self.v = v
        object.SetV(self, v, self.angle, self.autorot)
        task.New(self, function()
            local _v
            for _, con in ipairs(c) do
                task.Wait(con.wait or 0)
                _v = -self.v + (con.v or self.v)
                con.r = con.r or 0
                if con.func then
                    con.func(self)
                end
                for _ = 1, con.time do
                    self.v = self.v + _v / con.time
                    self.angle = self.angle + con.r
                    object.SetV(self, self.v, self.angle, self.autorot)
                    task.Wait()
                end
            end
            self.changed = true
        end)
    end })
    global_obj["bullet_setvxvy"] = Class(_bullet, { init = function(self, _x, _y, sty, col, vx, vy, stay)
        _bullet.init(self, sty, col, (stay or stay == nil) and true, true, false, _x, _y)
        self.vx = vx
        self.vy = vy
        self.navi = true
    end })
    global_obj["bullet_create_eff"] = Class(_bullet, { init = function(self, _x, _y, sty, col, v, a, blend)
        self.noTPbyYukari = true
        self.colli = false
        if type(_x) == "table" then
            _bullet.init(self, _x.imgclass, _x._index, false, true, false, _x.x, _x.y)
            self._blend = _x._blend
            task.New(self, function()
                for _ = 1, 11 do
                    if not IsValid(_x) then
                        break
                    end
                    self.x, self.y = _x.x, _x.y
                    task.Wait()
                end
                object.RawDel(self)
            end)
        else
            _bullet.init(self, sty, col, false, true, blend, _x, _y)
            if v and a then
                object.SetV(self, v, a, self.autorot)
            end
            task.New(self, function()
                task.Wait(11)
                object.RawDel(self)
            end)
        end

    end })
    local rand = math.random
    global_obj["little_charge_out"] = Class(_object, {
        leaf_insert = function(self, l, angle, lifetime, size)
            table.insert(self.leaf, {
                x = self.x,
                y = self.y,
                v = l / lifetime,
                a = angle + 180,
                timer = 0,
                lifetime = lifetime,
                size = size,
                hscale = size,
                vscale = size,
                _d_size = -(1 + rand() * 2) * size / lifetime,
                alpha = 125,
                rot = rand() * 360,
                omiga = (0.8 + rand() * 0.4) * ({ 1, -1 })[rand(2)]
            })
        end,
        init = function(self, _x, _y, a, r, g, b, s)
            self.x, self.y = _x, _y
            self.img = "circle_charge"
            self.layer = LAYER.ENEMY + 50
            self.group = GROUP.GHOST
            self.hide = false
            self.bound = true
            self.navi = false
            self.hp = 10
            self.maxhp = 10
            self.colli = true
            self._servants = {}
            self._blend, self._a, self._r, self._g, self._b = 'mul+add', 255, r, g, b
            self.leaf = {}
            task.New(self, function()
                PlaySound("enep00", 0.2, 0, false)
                local _s = 0
                local _a = a
                for i = 1, 30 do
                    if i < 15 then
                        self.class.leaf_insert(self, 150 + rand() * 50, rand() * 360, rand(40, 70), rand() * 0.7 + 0.8)
                        self.class.leaf_insert(self, 200 + rand() * 100, rand() * 360, rand(40, 70), rand() * 0.7 + 0.8)
                    end
                    self.hscale = _s
                    self.vscale = _s
                    self._a = _a
                    task.Wait()
                    _s = _s + s / 29
                    _a = _a - a / 29
                end
                while #self.leaf > 0 do
                    task.Wait()
                end
                object.Del(self)
            end)
        end,
        frame = function(self)
            _object.frame(self)
            local l
            for i = #self.leaf, 1, -1 do
                l = self.leaf[i]
                l.x = l.x + cos(l.a) * l.v
                l.y = l.y + sin(l.a) * l.v
                l.size = l.size + l._d_size
                l.hscale = l.size
                if l.timer > l.lifetime - 15 then
                    l.alpha = max(0, 125 * (l.lifetime - l.timer - 1) / 15)
                end
                if l.timer == l.lifetime then
                    table.remove(self.leaf, i)
                end
                l.timer = l.timer + 1
            end
        end,
        render = function(self)
            _object.render(self)
            for _, l in ipairs(self.leaf) do
                SetImageState("circle_charge_eff", "mul+add", l.alpha, 255, 255, 255)
                Render("circle_charge_eff", l.x, l.y, l.rot, l.hscale, l.vscale)
            end
        end
    })
    global_obj["leaf_eff"] = Class(object, {
        init = function(self, x, y, v, a, lifetime, size, r, g, b)
            self.img = "circle_charge_eff"
            self.x, self.y = x, y
            self.rot = ran:Float(0, 360)
            self.omiga = ran:Float(0.8, 1.2) * ran:Sign()
            self.hscale = size
            self.vscale = size
            self.layer = LAYER.TOP + 50
            self.group = GROUP.GHOST
            self.size = size
            self.v = v
            self.angle = a
            self.lifetime = lifetime
            self._x, self._y = x, y
            self.r, self.g, self.b = r, g, b
            self._s = ran:Float(1, 3)
        end,
        frame = function(self)
            if self.timer >= self.lifetime then
                object.Del(self)
                self.hide = true
            end
            local s = self.size + (-self._s * self.size / self.lifetime) * (self.timer - 1)
            local i = 0 + (90 / self.lifetime) * (self.timer - 1)
            local l = self.v * self.lifetime
            self.x = self._x + l * cos(self.angle) * sin(i)
            self.y = self._y + l * sin(self.angle) * sin(i)
            self.hscale = s
        end,
        render = function(self)
            local alpha = 125 - 125 + 125 * sin(90 - self.timer / self.lifetime * 90)
            SetImageState(self.img, 'mul+add', max(0, alpha), self.r, self.g, self.b)
            Render(self.img, self.x, self.y, self.rot, self.hscale, self.vscale)
        end
    })
    global_obj["saoqi_wave"] = Class(object, {
        init = function(self, _x, _y, rot, bb, s, r, g, b)
            self.x, self.y = _x, _y
            self.img = "saoqi2"
            self.layer = LAYER.ENEMY - 2
            self.group = GROUP.GHOST
            self.bound = false
            self._blend, self._a, self._r, self._g, self._b = 'mul+add', 0, r, g, b
            self.rot = rot
            self.hscale = 0
            self.vscale = 0
            self.alpha = 0
            self.boss = bb
            self.rr = r
            self.bb = b
            self.gg = g
            task.New(self, function()
                for i = 1, 60 do
                    self.hscale = 2 + (-2 + s) / 60 * i
                    self.vscale = self.hscale
                    task.Wait()
                end
            end)
        end,
        frame = function(self)
            task.Do(self)
            if IsValid(self.boss) then
                self.x = self.boss.x
                self.y = self.boss.y
            end
            if self.timer >= 60 then
                object.Del(self)
            end
            if self.timer <= 15 then
                self._a = self._a + 255 * 0.5 / 15
            end
            self._a = self._a - 255 * 0.5 / 60
        end,
        render = function(self)
            _object.render(self)
        end
    })

    global_obj["laser_line"] = Class(laser, {
        init = function(self, x, y, col, v, a, GrowTime, Width, Count, Head, nosound)
            laser.init(self, col, x, y, a, 0, 0, 0, Width or 8, Width or 8, Head or 0)
            laser.CyGrow(self, v, GrowTime, Count or 5, a, nosound)
        end,
        frame = function(self)
            if self.frame_new then
                self.frame_new(self)
            else
                laser.frame(self)
            end
        end,
        render = function(self)
            if self.render_new then
                self.render_new(self)
            else
                laser.render(self)
            end
        end
    })
    global_obj["laser_changeangle"] = Class(bent_laser, {
        init = function(self, x, y, index, l, w, v, a, ...)
            bent_laser.init(self, index, x, y, l, w, 4, w)
            PlaySound("lazer00", 0.1, self.x / 100)
            self.angle = a
            self.v = v
            object.SetV(self, v, self.angle, true)
            local c = { ... }
            task.New(self, function()
                local _v
                for _, con in ipairs(c) do
                    task.Wait(con.wait or 0)
                    _v = con.v or self.v
                    con.r = con.r or 0
                    if con.func then
                        con.func(self)
                    end
                    for t = 1, con.time do
                        self.v = self.v + (-self.v + _v) / con.time * t--奇怪的不想修复的算法
                        self.angle = self.angle + con.r
                        object.SetV(self, self.v, self.angle, true)
                        task.Wait()
                    end
                end
            end)
        end,
        frame = function(self)
            if self.frame_new then
                self.frame_new(self)
            else
                bent_laser.frame(self)
            end
        end,
        render = function(self)
            if self.render_new then
                self.render_new(self)
            else
                bent_laser.render(self)
            end
        end
    })

    sakura_big = Class(bullet, {
        init = function(self, x, y, a, o, vx, vy)
            bullet.init(self, sakura, 4, false, true)
            self.mx, self.my = x, y
            self.rot = a
            self.x, self.y = self.mx + cos(self.rot + 180) * 8, self.my + sin(self.rot + 180) * 8
            self.omiga = o
            self.mvx, self.mvy = vx, vy
            self.max, self.may = 0, 0
            self.mmaxvx, self.mmaxvy = 1e100, 1e100
        end,
        frame = function(self)
            bullet.frame(self)
            self.x, self.y = self.mx + cos(self.rot + 180) * 8, self.my + sin(self.rot + 180) * 8
            self.mx, self.my = self.mx + self.mvx, self.my + self.mvy
            self.mvx, self.mvy = self.mvx + self.max, self.mvy + self.may
            if abs(self.mvx) >= self.mmaxvx then
                self.mvx = sign(self.mvx) * self.mmaxvx
            end
            if abs(self.mvy) >= self.mmaxvy then
                self.mvy = sign(self.mvy) * self.mmaxvy
            end
        end
    })
    function sakura_big.New(x, y, fa, fo, v, a, func)
        local b
        for i = 1, 5 do
            b = New(sakura_big, x, y, fa + i * 72, fo, v * cos(a), v * sin(a))
            if func then
                func(b)
            end
        end
    end
    local New = New
    Create = {
        bullet_decel = function(x, y, style, col, fv, v, a, blend, stay)
            return New(global_obj["bullet_decel"], x, y, style, col, fv, v, a, blend, stay)
        end,
        bullet_accel = function(x, y, style, col, fv, v, a, blend, stay, wait, time)
            return New(global_obj["bullet_accel"], x, y, style, col, fv, v, a, blend, stay, wait, time)
        end,
        bullet_dec_acc = function(x, y, style, col, fv, v, a, blend, stay)
            return New(global_obj["bullet_dec_acc"], x, y, style, col, fv, v, a, blend, stay)
        end,
        bullet_dec_setangle = function(x, y, sty, col, ...)
            return New(global_obj["bullet_dec_setangle"], x, y, sty, col, ...)
        end,
        bullet_changeangle = function(x, y, sty, col, v, a, ...)
            return New(global_obj["bullet_changeangle"], x, y, sty, col, v, a, ...)
        end,
        bullet_setvxvy = function(x, y, sty, col, vx, vy, stay)
            return New(global_obj["bullet_setvxvy"], x, y, sty, col, vx, vy, stay)
        end,
        bullet_create_eff = function(x, y, sty, col, v, a, blend)
            return New(global_obj["bullet_create_eff"], x, y, sty, col, v, a, blend)
        end,
        little_charge_out = function(x, y, a, r, g, b, size)
            return New(global_obj["little_charge_out"], x, y, a, r, g, b, size)
        end,
        leaf_eff = function(x, y, v, a, lifetime, size, r, g, b)
            return New(global_obj["leaf_eff"], x, y, v, a, lifetime, size, r, g, b)
        end,
        saoqi_wave = function(x, y, rot, master, size, r, g, b)
            return New(global_obj["saoqi_wave"], x, y, rot, master, size, r, g, b)
        end,
        laser_line = function(x, y, col, v, a, GrowTime, Width, Scale, Head, nosound)
            return New(global_obj["laser_line"], x, y, col, v, a, GrowTime, Width, Scale, Head, nosound)
        end,
        laser_changeangle = function(x, y, index, l, w, v, a, ...)
            return New(global_obj["laser_changeangle"], x, y, index, l, w, v, a, ...)
        end
    }
end --通用物

function ParticleLaserBent(pR, pG, pB, x, y, index, length, w, v, a, ...)
    local l = Create.laser_changeangle(x, y, index, length, w, v, a, ...)
    l.particle = {}
    l.pcol = { pR, pG, pB }
    function l:frame_new()
        bent_laser.frame(self)
        if self.timer < 90 then
            local _a = ran:Float(0, 360)
            local _v = ran:Float(3, 6)
            table.insert(self.particle, {
                x = self.x, y = self.y,
                vx = cos(_a) * _v, vy = sin(_a) * _v,
                alpha = ran:Float(200, 250), timer = 0,
                r = self.pcol[1], g = self.pcol[2], b = self.pcol[3]
            })
        end
        local p
        for i = #self.particle, 1, -1 do
            p = self.particle[i]
            p.x = p.x + p.vx
            p.y = p.y + p.vy
            p.vx = p.vx - p.vx * 0.04
            p.vy = p.vy - p.vy * 0.04
            if p.timer > 10 then
                p.alpha = max(p.alpha - 5, 0)
                if p.alpha == 0 then
                    table.remove(self.particle, i)
                end
            end
            p.timer = p.timer + 1
        end
        self.bound = (#self.particle == 0) and (self.timer > 30)

    end
    function l:render_new()
        bent_laser.render(self)
        for _, p in ipairs(self.particle) do
            SetImageState("bright", "mul+add", p.alpha, p.r, p.g, p.b)
            Render("bright", p.x, p.y, 0, 10 / 150)
        end
    end
    return l
end
function ParticleLaserLine(pR, pG, pB, x, y, col, v, a, GrowTime, Width, Scale, Head, nosound)
    local l = Create.laser_line(x, y, col, v, a, GrowTime, Width, Scale, Head, nosound)
    l.particle = {}
    l.pcol = { pR, pG, pB }
    function l:frame_new()
        laser.frame(self)
        local len = self.l1 + self.l2 + self.l3
        local hx, hy = self.x + cos(self.rot) * len, self.y + sin(self.rot) * len
        if self.timer < 90 then
            local _a = ran:Float(0, 360)
            local _v = ran:Float(3, 6)
            table.insert(self.particle, {
                x = hx, y = hy,
                vx = cos(_a) * _v, vy = sin(_a) * _v,
                alpha = ran:Float(200, 250), timer = 0,
                r = self.pcol[1], g = self.pcol[2], b = self.pcol[3]
            })
        end
        local p
        for i = #self.particle, 1, -1 do
            p = self.particle[i]
            p.x = p.x + p.vx
            p.y = p.y + p.vy
            p.vx = p.vx - p.vx * 0.04
            p.vy = p.vy - p.vy * 0.04
            if p.timer > 10 then
                p.alpha = max(p.alpha - 5, 0)
                if p.alpha == 0 then
                    table.remove(self.particle, i)
                end
            end
            p.timer = p.timer + 1
        end
        self.bound = (#self.particle == 0) and (self.timer > 30)

    end
    function l:render_new()
        laser.render(self)
        for _, p in ipairs(self.particle) do
            SetImageState("bright", "mul+add", p.alpha, p.r, p.g, p.b)
            Render("bright", p.x, p.y, 0, 10 / 150)
        end
    end
    return l
end

---一种新的创建obj的方式
---创建后自行用函数对他操作
function NewObject(base_class)
    local obj = New(object)
    obj.class = base_class
    return obj
end

function ChangeMusicByFade(curbgm, newbgm, time, bgm_start_time)
    if curbgm == newbgm then
        curbgm = nil
    end
    task.New(stage.current_stage, function()
        if bgm_start_time and bgm_start_time < 0 then
            bgm_start_time = musicList[newbgm][1] + bgm_start_time
        end
        PlayMusic2(newbgm, 0, bgm_start_time)
        for v = 1, time do
            if curbgm then
                SetBGMVolume(curbgm, 1 - v / time)
            end
            SetBGMVolume(newbgm, v / time)
            coroutine.yield()
        end
        if curbgm then
            StopMusic(curbgm)
        end
    end)
end

loadLanguageModule("bossname", "mod")
loadLanguageModule("tutorial", "mod\\game\\scene_lang")
DoFile("mod\\music.lua")
DoFile("mod\\addition\\stg_level.lua")
DoFile("mod\\active\\init.lua")
DoFile("mod\\weather\\weather_event.lua")

if GlobalLoading then
    DoFile("shader\\shader.lua")
    DoFile("mod\\init_other.lua")
    DoFile("mod\\init_obj.lua")
    DoFile("mod\\game\\init.lua")
    DoFile("mod\\defachievement.lua")
    DoFile("mod\\challenge\\init.lua")
else
    table.insert(LoadRes, function()
        DoFile("shader\\shader.lua")
        DoFile("mod\\init_other.lua")
        DoFile("mod\\init_obj.lua")
        DoFile("mod\\game\\init.lua")
        DoFile("mod\\defachievement.lua")
        DoFile("mod\\challenge\\init.lua")
    end)
end

---开发者模式
if FileExist("Creative.lua") then
    Include("Creative.lua")
end

InitAllClass()



